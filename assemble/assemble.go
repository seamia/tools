// Copyright 2020 Seamia Corporation. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"bufio"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
	"sort"
	"strings"
	"time"
)

/*
	this is a small tool intended to assemble (embed) a few external (text) files into one *.go file
	(e.g. to avoid dependencies on external files)

	what to do is driven by "prescription" file, that describes what to do.
	this file looks like this:
	{
		"package": "name-of-your-package",
		"comment": "this is a colllection files =)",
		"list": "allTogetherNow",
		"include": {
			"scriptCreate": "./generated/create.sql",
			"scriptGrant": "./generated/grants.sql",
			"scriptSeed": "./generated/seed.sql",
			"scriptTable": "./generated/tables.sql",
			"scriptTags": "./generated/tags.sql",
			"scriptViews": "./generated/views.sql"
		}
	}

	warning:
	since there no encryption, compression or any other form of obfuscation - all your (potential) "secrets" present
	in the original files - will be plain visible in the compiled binary. well, duh =)
*/

type Prescription struct {
	Package string            `json:"package"`
	Include map[string]string `json:"include"`
	List    string            `json:"list,omitempty"`
	Comment string            `json:"comment,omitempty"`
}

const (
	thisTool = "github.com/seamia/tools/assemble"
)

func main() {
	if len(os.Args) < 3 {
		fmt.Fprintf(os.Stderr, "USAGE: assemble prescription output\n")
		os.Exit(7)
	}

	prescriptionName := os.Args[1]
	outputName := os.Args[2]

	prescriptionRaw, err := ioutil.ReadFile(prescriptionName)
	quitOnError(err, "no file")

	var prescription Prescription
	err = json.Unmarshal(prescriptionRaw, &prescription)

	f, err := os.Create(outputName)
	quitOnError(err, "no create")
	w := bufio.NewWriter(f)
	defer func() {
		w.Flush()
		f.Close()
	}()

	write := func(format string, a ...interface{}) {
		_, err := fmt.Fprintf(w, format, a...)
		quitOnError(err, "no write")
	}

	write("// WARNING: this file was generated -> do not hand modify -> your changes will be lost!\n")
	write("// (generated from `%s` by `%s` on %s)\n\n", prescriptionName, thisTool, time.Now())

	if len(prescription.Package) == 0 {
		prescription.Package = "main" // better than nothing
	}

	write("package %s\n\n", prescription.Package)

	if len(prescription.Comment) > 0 {
		comment := strings.ReplaceAll(prescription.Comment, "\\n", "\n")
		write("/* %s */\n\n", comment)
	}
	write("const (\n")

	// the stuff in the block below is to see/count if there is a need to expand any of the embedded data (what keys need to be expanded, if any)
	templates := make(map[string]int)
	templatesFunc := func(key string) string {
		templates[key]++
		return ""
	}

	names := make([]string, 0, len(prescription.Include))
	for name, fileName := range prescription.Include {
		raw, err := ioutil.ReadFile(fileName)
		quitOnError(err, "no include (%s)", fileName)
		corrected := escape(string(raw))
		names = append(names, name)

		_ = os.Expand(string(raw), templatesFunc)

		write("\t// content of the file %s\n", fileName)
		write("\t%s = \"%s\"\n\n", name, corrected)
	}

	write(")\n") // the end of "const" section

	write("\nvar (\n")
	if len(prescription.List) > 0 {
		list := strings.Join(names, ", ")
		write("\t%s = []string{%s}\n", prescription.List, list)
	}

	const keywordsName = "needToBeExpanded"
	if len(templates) > 0 {
		list := make([]string, 0, len(templates))
		for key := range templates {
			list = append(list, key)
		}
		sort.Strings(list)
		txt := "\"" + strings.Join(list, "\", \"") + "\""
		write("\t%s = []string{ %s }\n", keywordsName, txt)
	} else {
		write("\t%s = []string{}\n", keywordsName)
	}

	write(")\n") // the end of "var" section
}

var translate = map[string]string{
	"\n": "\\n",
	"\t": "\\t",
	"\r": "\\r",
	"\"": "\\\"",
}

func escape(raw string) string {
	for from, to := range translate {
		raw = strings.ReplaceAll(raw, from, to)
	}
	return raw
}

func quitOnError(err error, format string, a ...interface{}) {
	if err != nil {
		fmt.Fprintf(os.Stderr, format, a...)
		fmt.Fprintf(os.Stderr, "\n(error: %v)\n", err)
		os.Exit(7)
	}
}
